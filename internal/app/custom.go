// Code generated by RedSock CLI.
// DO EDIT, DON'T DELETE THIS FILE.

package app

import (
	"context"
	"strings"
	"time"

	"github.com/sirupsen/logrus"
	"go.redsock.ru/rerrors"
	"go.redsock.ru/toolbox/closer"
	"golang.org/x/sync/errgroup"

	"go.vervstack.ru/Velez/internal/clients/cluster_clients"
	"go.vervstack.ru/Velez/internal/clients/node_clients"
	"go.vervstack.ru/Velez/internal/cluster"
	"go.vervstack.ru/Velez/internal/cluster/autoupgrade"
	"go.vervstack.ru/Velez/internal/middleware"
	"go.vervstack.ru/Velez/internal/pipelines"
	"go.vervstack.ru/Velez/internal/service"
	"go.vervstack.ru/Velez/internal/service/service_manager"
	"go.vervstack.ru/Velez/internal/transport/control_plane_api_impl"
	"go.vervstack.ru/Velez/internal/transport/service_api_impl"
	"go.vervstack.ru/Velez/internal/transport/vcn_api_impl"
	"go.vervstack.ru/Velez/internal/transport/velez_api_impl"
	"go.vervstack.ru/Velez/internal/workers"
	"go.vervstack.ru/Velez/pkg/docs"
	"go.vervstack.ru/Velez/pkg/velez_api"
)

type Custom struct {
	// NodeClients - hardware scanner, docker, and wrappers
	NodeClients node_clients.NodeClients

	// ClusterClients - contains verv cluster's dependencies
	ClusterClients cluster_clients.ClusterClients

	// Services - contains business logic services
	Services  service.Services
	Pipeliner pipelines.Pipeliner
	// Api implementation
	ApiGrpcImpl         *velez_api_impl.Impl
	ControlPlaneApiImpl *control_plane_api_impl.Impl
	VpnApiImpl          *vcn_api_impl.Impl
	ServiceApiImpl      *service_api_impl.Impl

	//	Background workers
	DeployWatcher workers.Worker
}

func (c *Custom) Init(a *App) (err error) {
	logrus.SetFormatter(&logrus.JSONFormatter{})
	logrus.SetLevel(extractLogLevel(a.Cfg.Environment.LogLevel))

	err = c.InitClients(a)
	if err != nil {
		return rerrors.Wrap(err, "error during client initialization")
	}

	err = c.InitServiceLayer(a)
	if err != nil {
		return rerrors.Wrap(err, "error during service initialization")
	}

	err = c.InitApiServer(a)
	if err != nil {
		return rerrors.Wrap(err, "error during server initialization")
	}

	c.DeployWatcher = workers.NewDeployWatcher(c.Services, c.Pipeliner, c.ClusterClients, time.Second*5)
	go c.DeployWatcher.Start(a.Ctx)
	closer.Add(c.DeployWatcher.Stop)

	return nil
}

func (c *Custom) Start(ctx context.Context) error {
	errG, ctx := errgroup.WithContext(ctx)
	errG.Go(func() error {
		err := autoupgrade.New(c.NodeClients.Docker().Client(), time.Second*30, c.Pipeliner).Start()
		if err != nil {
			return rerrors.Wrap(err, "error starting autoupgrade")
		}

		return nil
	})

	err := errG.Wait()
	if err != nil {
		return rerrors.Wrap(err, "error starting custom workers")
	}

	return nil
}

func (c *Custom) Stop() error {

	return nil
}

func (c *Custom) InitServiceLayer(a *App) error {
	if c.NodeClients == nil || c.ClusterClients == nil {
		return rerrors.New("clients not initialized")
	}

	var err error
	c.Services, err = service_manager.New(a.Ctx, c.NodeClients, c.ClusterClients)
	if err != nil {
		return rerrors.Wrap(err, "error initializing service manager")
	}

	c.Pipeliner = pipelines.NewPipeliner(c.NodeClients, c.ClusterClients, c.Services)

	logrus.Info("shut down on exit is set to: ", a.Cfg.Environment.ShutDownOnExit)
	if a.Cfg.Environment.ShutDownOnExit {
		closer.Add(smerdsDropper(c.Services.SmerdManager()))
	}

	return nil
}

func (c *Custom) InitApiServer(a *App) error {
	c.ApiGrpcImpl = velez_api_impl.NewImpl(a.Cfg, c.Services, c.Pipeliner)
	c.ControlPlaneApiImpl = control_plane_api_impl.New(c.Services, c.Pipeliner)
	c.VpnApiImpl = vcn_api_impl.New(c.ClusterClients, c.Pipeliner)
	c.ServiceApiImpl = service_api_impl.New(c.Pipeliner, c.Services)

	a.ServerMaster.AddImplementation(c.ApiGrpcImpl, c.ControlPlaneApiImpl, c.VpnApiImpl, c.ServiceApiImpl)
	a.ServerMaster.AddHttpHandler(docs.Swagger())

	if !a.Cfg.Environment.DisableAPISecurity {
		a.ServerMaster.AddServerOption(
			middleware.GrpcIncomingInterceptor(
				c.NodeClients.LocalStateManager().ValidateVelezPrivateKey))
	}

	a.ServerMaster.AddServerOption(middleware.LogInterceptor(), middleware.PanicInterceptor())

	return nil
}

func (c *Custom) InitClients(a *App) (err error) {
	c.NodeClients, err = node_clients.NewNodeClients(a.Ctx, a.Cfg)
	if err != nil {
		return rerrors.Wrap(err, "error initializing internal clients")
	}

	c.ClusterClients, err = cluster.Setup(a.Ctx, a.Cfg, c.NodeClients)
	if err != nil {
		return rerrors.Wrap(err, "error setting up verv services")
	}

	return nil
}

func smerdsDropper(smerdService service.ContainerService) func() error {
	return func() error {
		logrus.Infof("ShutDownOnExit env variable is set to TRUE. Dropping launched smerds")
		logrus.Infof("Listing launched smerds")
		ctx := context.Background()

		smerds, err := smerdService.ListSmerds(ctx, &velez_api.ListSmerds_Request{})
		if err != nil {
			return err
		}

		names := make([]string, 0, len(smerds.Smerds))

		for _, sm := range smerds.Smerds {
			names = append(names, sm.Name)
		}

		logrus.Infof("%d smerds is active. %v", len(smerds.Smerds), names)

		dropReq := &velez_api.DropSmerd_Request{
			Uuids: make([]string, len(smerds.Smerds)),
		}

		for i := range smerds.Smerds {
			dropReq.Uuids[i] = smerds.Smerds[i].Uuid
		}

		logrus.Infof("Dropping %d smerds", len(smerds.Smerds))

		dropSmerds, err := smerdService.DropSmerds(ctx, dropReq)
		if err != nil {
			return err
		}

		logrus.Infof("%d smerds dropped successfully", len(dropSmerds.Successful))
		if len(dropSmerds.Successful) != 0 {
			logrus.Infof("Dropped smerds: %v", dropSmerds.Successful)
		}

		if len(dropSmerds.Failed) != 0 {
			logrus.Errorf("%d smerds failed to drop", len(dropSmerds.Failed))
			for _, f := range dropSmerds.Failed {
				logrus.Errorf("error dropping %s. Cause: %s", f.Uuid, f.Cause)
			}
		}

		return nil
	}
}

func extractLogLevel(str string) logrus.Level {
	switch strings.ToLower(str) {
	case logrus.PanicLevel.String():
		return logrus.PanicLevel
	case logrus.FatalLevel.String():
		return logrus.FatalLevel
	case logrus.ErrorLevel.String():
		return logrus.ErrorLevel
	case logrus.WarnLevel.String():
		return logrus.WarnLevel
	case logrus.InfoLevel.String():
		return logrus.InfoLevel
	case logrus.DebugLevel.String():
		return logrus.DebugLevel
	case logrus.TraceLevel.String():
		return logrus.TraceLevel

	default:
		return logrus.InfoLevel
	}
}
